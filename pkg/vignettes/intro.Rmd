---
title: "Getting started with lumberjack"
author: "Mark van der Loo"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc : true
vignette: >
  %\VignetteIndexEntry{Getting started with lumberjack}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE}
library(lumberjack)
```

This package allows you to monitor changes in data as they get processed. It
implements an easy-to-use and extensible logging framework, and comes with a few
data loggers implemented.

This vignette will show you how to get started and what the default loggers do. The [extending lumberjack](extending.html) vignette explains how to build your own loggers.



## Installation

Install the package with
```{r,eval=FALSE}
install.packages("lumberjack")
```

## The lumberjack workflow
So you want to know who does what to your data as it flows through your
process. Here's the workflow that allows you to do it using the `lumberjack`
package. (Note the use of `%L>%`!)
```{r}
out <- women %L>%
  start_log() %L>%
  identity() %L>%
  head() %L>%
  dump_log()
read.csv("simple_log.csv")
```
Lets go through this step by step to see what happened. The start of the script 
defines an output variable `out` and passes `women` to the lumberjack (`%L>%`).
Next, the function `start_log` makes sure that logging starts from there. We are
now ready to start performing logged transformations on our dataset. First, we 
apply the `identity` function, which does exactly nothing. Then, the `head` 
function selects the first six rows in of the dataset and `dump_log()`
writes the log to a csv file, which we then read in. After the log is dumped,
logging stops automatically (by default).


The logging data consists of a step number, a timestamp, the expression
evaluated to transform the data, and an indicator whether the data had changed
at all. As expected, the `identity` function hasn't changed anything and the
`head` function cuts of all records below the sixth row.

By the way, the variable `out` contains the first six records of the `women` dataset as
expected.
```{r}
out
```


You have now seen the most important functions of the package. Let's summarize them.

- `start_log(data, log)`: start logging using possibly a custom logger (see next section)
- `%L>%`: the lumberjack. a logging-aware function composition operator ('pipe').
- `dump_log(data, stop, ...)`: dump the log for `data` (if present)
- `stop_log(data)`: stop logging.

All these functions are data-in, data-out. You are probably used to this from 
using [dplyr](http://dplyr.tidyverse.org/) or one of its siblings. However, the 
`lumberjack` functions are not limited to `data.frame`-like objects. In
principle, changes to any object type can be logged, but it depends on the
logger whether that will actually work -- most will expect a particular data
structure.

## Changing the logger

Just tell `start_log()` what logger to use. In the example below we use the
builtin `cellwise` logger. For this logger it is necessary to have a key column
that identifies the rows uniquely so we add that first (we use `within` here,
this is base R's equivalent to `dplyr`'s `mutate`).
```{r}
logfile <- tempfile(fileext = ".csv") # where the logging info is written
women$a_key <- sprintf("W%02d", seq_len(nrow(women)))   # add a primary key to 'women'

# make the small example ea bit smaller
wom <- head(women,5)

out <- wom %L>%
  start_log( log = cellwise$new(key="a_key") ) %L>%
  within(height <- sqrt(height)) %L>%
  within(weight <- weight*2) %L>%
  dump_log(file=logfile, stop=TRUE)

read.csv(logfile)
```

## Available loggers

Here's a short overview of known loggers.

### In the lumberjack package

- `simple` Just check whether data has changed.
- `cellwise` Track changes per cell (incl. old value, new value)
- `filedump` Dump a file after each step (including the zeroth step.)
- `expression_logger` Track the result of any expression

### In other packages

- `validate::lbj_rules` Track changes in data quality measured by validation rules ([validate](https://CRAN.R-project.org/package=validate) version >= 0.2.0).
- `validate::lbj_cells` Track changes in cell filling and cell counts ([validate](https://CRAN.R-project.org/package=validate) version >=0.2.0 ).
- `daff::lbj_daff` Use data-diff to track changes in data frame-like objects. ([daff](https://CRAN.R-project.org/package=daff) version >= 3.3)


See the [extending lumberjack](extending.html) vignette on how to build your own loggers.

## One more example: the expression logger

The expression logger allows you to log the result of one or more expressions that will
be evaluated after each data processing step. For example, suppose we want to follow the 
mean and variance of variables in the `women` dataset as it gets processed.

```{r}
logger <- expression_logger$new(mnh = mean(height), sdh = sd(height))
out <- women %L>%
  start_log(logger) %L>%
  transform(height <- height*2.54) %L>% # height in cm
  transform(weight <- weight*0.453592) %L>%
  dump_log()

read.csv("expression_log.csv",stringsAsFactors = FALSE)
```




## Changing logger behaviour
There are two ways to change how a logger behaves. By setting options
at initialization and by setting options when dumping a log.


### Setting options for the logger

The `start_log` function adds a logging object as an attribute to its input 
data. By default, this is the `simple` logger, which only checks whether data 
has changed at all. The behavior of this logger can be changed by 
passing options when it is created. To see this, have a look at the complete
call, as it is executed by default.
```{r}
dat <- start_log(women, log = simple$new())
```
The expression `simple$new()` creates a new logging object, and `start_log`
makes sure it is attached as an attribute to the copy of the `women` dataset
stored in `dat`. The simple logger has one option called `verbose`, that can be set when calling `$new`. The default is `TRUE`, here we set it to `FALSE`.
```{r}
dat <- start_log(women, log=simple$new(verbose=FALSE))
```
The effect is that no message is printed when the log is dumped to file.
```{r}
out <- dat %L>% identity() %L>% dump_log()
read.csv("simple_log.csv")
```

Note that the available options depend logger you use. Look at the logger's 
helpfile (`?simple`, `?cellwise`) to see all options.


### Setting options for the output

For the simple logger, the default output file is `simple_log.csv` This can be
changed when calling `dump_log`. 
```{r}
out <- dat %L>% 
  start_log() %L>% 
  identity() %L>% 
  dump_log(file="log_all_day.csv")
read.csv("log_all_day.csv")
```
The function `dump_log` passes most of its arguments to the logger's `$dump()`
method. See the help file of the logger for the options (`?simple`, `?cellwise`).



### Options for other loggers

Loggers can come in different forms. In principle, authors are free to use R6
classes (as is done here), Reference classes, or anything else that follows the
lumberjack API. This means that the way that logging objects are initialized may
vary from logger to logger. Check the documentation of a logger to see how to
operate it. Maintainers of packages that offer loggers that work with the
lumberjack are kindly requested to list the `lumberjack` in the `Enhances` field
of the `DESCRIPTION` file, so they can be found through `lumberjack`'s CRAN page.

## Properties of the lumberjack

There are several function composition ('pipe') operators in the R community, 
including [magrittr](https://cran.r-project.org/package=magrittr), 
[pipeR](https://cran.r-project.org/package=pipeR) and 
[yapo](https://github.com/piccolbo/yapo). All have different behavior. 


The  lumberjack operator behaves as a simplified version of the `magrittr` pipe
operator. Here are some examples.
```r
# pass the first argument to a function
1:3 %L>% mean()

# pass arguments using "."
TRUE %L>% mean(c(1,NA,3), na.rm = .)

# pass arguments to an expression, using "."
1:3 %L>% { 3 * .}

# in a more complicated expression, return "." explicitly
women %L>% { .$height <- 2*.$height; . }
```

The main differences with `magrittr` are that 

- there is no assignment-pipe like `%<>%`.
- it does not allow you to define functions in the magrittr style: `a <- . %>% sin(.)`
- you cannot do things like `pi %>% sin` and expect an answer

## Logging changes on non-data.frame objects

This is possible, but the logger has to support it. The `simple` logger works
for any object, but the `cellwise` logger works on data.frame-like objects only.

```{r}
out <- 1:3 %L>% 
  start_log() %L>%
  {.*2} %L>%
  dump_log(file="foo.csv")

print(out)

read.csv("foo.csv")
```



